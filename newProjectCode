#include <math.h>

#define sensorInput A1
#define motorDirPin 4
#define motorPWMPin 5
#define ticksPerDeg 14.26

/* ------------------------------------------------
 *  Exaggerated Vibration and Recoil from Impact
 *  
 *  From Gleeson and Johnson's 2010 paper on cartoon haptics
 *  
 *  PLEASE OPEN THE SERIAL MONITOR
 *  
 *  Press S1 for a vibration and recoil force amplitude that
 *  is proportional to the incoming velocity. This means
 *  a fast incoming velocity will give a large force amplitude
 *  for oscillation and recoil
 *  
 *  Press S2 for a vibration and recoil force amplitude that
 *  is inversely proportional to the incoming velocity. This 
 *  means a slow incoming velocity will give a large force 
 *  amplitude for oscillation and recoil
 *  
 *  Press S3 for an ordinary virtual wall with no exaggerated
 *  recoil or vibration
 *  
 *  If you intend to feel the effect of a slow velocity when 
 *  approaching the virtual wall in the proportional or
 *  inversely proportional cases (S1 and S2), you must move
 *  VERY slowly up to the wall at -15 degrees, otherwise the 
 *  effect is not as noticeable due to the small dynamic range 
 *  of the motor on our haptic paddles. 
 *    
 *  Travis Allen, ME EN 7240 S'21
 */


// Button Variables -------------------------------
const int er0 = 0;
const int prop = 1;
const int inv = 2;
const int vw = 3;
const int er1 = 4;
const int er2 = 5;
int counts = 0;
int key_Pressed = er0;

// Virtual Wall Variables -------------------------------
float angleVal = 0.0;
float prevAngleVal = 0.0;
float velocity = 0.0;
double duty = 0;                  // duty cycle (between 0 and 255)
unsigned int motorCommand = 0;
float pGain = .1;
float totalTorque = 0.0;
float posError = 0;
double samplingTime = 0.0;
unsigned long prevTime =  0;
unsigned long currentTime =  0;
float prevVelocity = 0.0;
float tau = .0005;

// Ringing Variables -------------------------------------
// variables
float impactVel = 0.0;

float sensorReading = 0.0;
float dxdt = 0.0;             // change of rate of position
float alpha = 0.2;            // low-pass filter constant

float targetPos = -20.0;      // degrees, target position of event-based wall
float targetPos2 = 20.0;      // degrees, target position of regular wall
float targetVel = 0.0;
float reactionForce = 0.0;

float wallEffort = 0.0;       // output value of PD controller from either event-based or regular wall

boolean event = 0;            // flag to signal if the event has occured
float eventSignal = 0.0;      // output value of decaying sinusoid
float lambda = 0.0;           // Decay constant. Higher number means faster decay rate
float freq = 5;             // Hz, frequency of oscillations
float A = 0.0;                // Initial magnitude of decaying sinusoid
float eventResetPos = -20;  // When you move away from the target position by this much, it will reset the trigger for the event

float velError = 0.0;

unsigned long startTime = 0.0;// global start time of event
double t = 0.0;               // new local time reference used for the event
float cutoff = 0.0;


void setup() {
  pinMode(sensorInput, INPUT);
  pinMode(motorPWMPin, OUTPUT);
  pinMode(motorDirPin, OUTPUT);
  pinMode(13, OUTPUT);  
  Serial.begin(9600);
  while (!Serial);    // Wait until serial link is established 
                      // Comment out if not using USB connection
  // Set PWM Frequency
  setPwmFrequency(motorPWMPin,1);

  // Read values to initialize "previous" variables
  prevAngleVal = analogRead(sensorInput);
  prevTime = millis();
  
  // Print instructions one time
  Serial.println("Exaggerated Vibration and Recoil from Impact");
  Serial.println("From Gleeson and Johnson's 2010 paper on cartoon haptics");
  Serial.println();
  Serial.println("Press S1 for proportional magnitudes");
  Serial.println("Press S2 for inverse magnitudes");
  Serial.println("Press S3 for virtual wall");
  Serial.println();
  Serial.println("Press buttons to switch between modes");
 
}

void loop()
{
  key_Pressed = Read_Buttons();  // read the buttons

  switch (key_Pressed)           // Do something based on the button pressed
  { 
    case prop:
      {
        analogWrite(motorPWMPin,0);
        counts = 1;
        Serial.println("proportional magnitudes"); // Print the key that was pressed
        delay(8000);                               // Delay for switch debounce
        break;
      }
    case inv:
      {
        analogWrite(motorPWMPin,0);
        counts = 2;
        Serial.println("inverse magnitudes");
        delay(7000);                                // Delay for switch debounce
        break;
      }
    case vw:
      {
        analogWrite(motorPWMPin,0);
        counts = 3;
        Serial.println("virtual wall");
        delay(8000);                                // Delay for switch debounce
        break;
      }
    case er1:
      {
        analogWrite(motorPWMPin,0);
        Serial.println("press a different button");
        delay(8000);                                // Delay for switch debounce
        break;
      }
    case er2:
      {
        analogWrite(motorPWMPin,0);
        Serial.println("press a different button");
        delay(8000);                                // Delay for switch debounce
      }
    case er0:
      {
        break;
      }
  }
  if(key_Pressed != er0)   // Blink LED and debounce switch
  {
  digitalWrite(13, HIGH);  // Turn LED on
  delay(500);              // Delay for switch debounce & LED blink
  digitalWrite(13, LOW);   // Turn LED off
  }

  
  //-----------------------------------------------------------------------------
  // Proportional rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  if(counts == 1){

    // read the current position1
    angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;

    // Determine time that has passed since the last update
    currentTime = millis() / 64.0 ;                             // In milliseconds. Dividing by 64 corrects for setting the PWM frequency to 62.5 kHz
    samplingTime = currentTime - prevTime;                      // In milliseconds
  
    // Compute raw angular velocity
    if (samplingTime != 0.0){                                   // only calculates derivative if samplingTime is non-zero, otherwise it will not update dxdt
      dxdt = (angleVal - prevAngleVal) / samplingTime * 1000.0; // degrees per second
    }
    velocity = alpha * dxdt + (1.0 - alpha) * prevVelocity;     // low-pass filter with variable filtering parameter alpha
  
    posError = targetPos - angleVal;                            // position error of event-based wall
    
  
    
    // Event-Based Code
    if (posError > 0.0) {                           // If you're in the event wall
      if (event == 0) {                             // and an event hasn't been triggered,
        startTime = currentTime;                    // then keep track of the new reference time for the decaying sinusoid,
        event = 1;                                  // trigger a new event,
        impactVel = velocity;                       // and record the impact velocity.
      }
      wallEffort = posError * pGain;                // Calculate the effort produced solely by the event wall based on wall stiffness, pGain
    } else {                                        // or else if you're not in either wall,
      wallEffort = 0.0;                             // then set the wall effort to be zero.
    }
  
    if(event == 1){
      if(impactVel < -15){
      t = (currentTime - startTime) / 1000.0;                                           // Use new time variable in units of seconds which the decaying sinusoid will reference
      eventSignal = 0.03*abs(impactVel) * exp(-1 * t) * sin(6.283185 * freq * t);   // Formula for decaying sinusoid as a function of impact velocity. Note: 6.283185 = 2*PI
      eventSignal = eventSignal + 4;
      }
    }
    totalTorque = wallEffort + eventSignal ;     // Find total torque by superimposing decaying sinusoid on force produced solely by either wall

    //cutoff = t + 3000;
  
    if ((posError < eventResetPos)) {                 //  || (currentTime > cutoff)
      event = 0;                                    // then reset the trigger for the event.
      eventSignal = 0;
    }
    
    // Compute the duty cycle required to generate torque at the motor
    duty = abs(totalTorque);
  
    // Make sure the duty cycle is between 0 and 100%
    if (duty > 1) {
      duty = 1;
    } else if (duty < 0) {
      duty = 0;
    }
  
    // Determine correct direction for motor torque
    if (totalTorque > 0.0) {
      digitalWrite(motorDirPin, HIGH);
      motorCommand = (int)(duty * 255);         // convert duty cycle to output signal
    } else {
      digitalWrite(motorDirPin, LOW);
      motorCommand = (int)(duty * 255);         // convert duty cycle to output signal
    }
    
    // Check to see if the velocity is infinity or not a number. This can happen when 
    // samplingTime equals zero. Will blink on board LED and shut-off motors
    if (velocity == INFINITY || velocity == NAN || isnan(velocity) || isinf(velocity)) {
      for (int i = 0; i < 3; i++) {
        digitalWrite(13, HIGH);
        delay(10000000.0 / 512.0); 
        digitalWrite(13, LOW);
        delay(10000000.0 / 512.0);
      }
      delay(10000000.0 / 128.0); // delays about 1 second
      motorCommand = 0;
    }
  
    analogWrite(motorPWMPin, motorCommand);     // output the signal
  
    // Update values with the current state
    prevAngleVal = angleVal;
    prevVelocity = velocity;
    prevTime = currentTime;
         
       
  } // if counts == 1
  
  //-----------------------------------------------------------------------------
  // Inverse rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  else if(counts == 2){
       analogWrite(motorPWMPin,0);
  }
  
  //-----------------------------------------------------------------------------
  // Virtual Wall
  //-----------------------------------------------------------------------------
  else if(counts == 3){
       analogWrite(motorPWMPin,0);
  }
}
//-------------------------------------------------------------------------------
//  Function to read onboard buttons
//-------------------------------------------------------------------------------
int Read_Buttons()
{
  int adc_key_in = analogRead(A7);      // read the value of the key resistor divider
    if (adc_key_in >= 1000) return er0; 
  if (adc_key_in < 30)   return prop; 
  if (adc_key_in < 200)  return inv;
  if (adc_key_in < 500)  return vw;
  if (adc_key_in < 700)  return er1;
  if (adc_key_in < 990)  return er2;

  return er0;  // 
}

// --------------------------------------------------------------
// Function to set PWM Freq -- DO NOT EDIT
// --------------------------------------------------------------
void setPwmFrequency(int pin, int divisor) {
  byte mode;
  if(pin == 5 || pin == 6 || pin == 9 || pin == 10) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 64: mode = 0x03; break;
      case 256: mode = 0x04; break;
      case 1024: mode = 0x05; break;
      default: return;
    }
    if(pin == 5 || pin == 6) {
      TCCR0B = TCCR0B & 0b11111000 | mode;
    } else {
      TCCR1B = TCCR1B & 0b11111000 | mode;
    }
  } else if(pin == 3 || pin == 11) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 32: mode = 0x03; break;
      case 64: mode = 0x04; break;
      case 128: mode = 0x05; break;
      case 256: mode = 0x06; break;
      case 1024: mode = 0x7; break;
      default: return;
    }
    TCCR2B = TCCR2B & 0b11111000 | mode;
  }
}
