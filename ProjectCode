#include <math.h>

#define sensorInput A1
#define motorDirPin 4
#define motorPWMPin 5
#define ticksPerDeg 14.26

// Button Variables -------------------------------
const int er0 = 0;
const int prop = 1;
const int inv = 2;
const int vw = 3;
const int er1 = 4;
const int er2 = 5;
int counts = 0;
int key_Pressed = er0;

// Virtual Wall Variables -------------------------------
float angleVal = 0.0;
float prevAngleVal = 0.0;
float velocity = 0.0;
float targetPos = 0.0;
double duty = 0;                  // duty cycle (between 0 and 255)
unsigned int motorComman#include <math.h>

#define sensorInput A1
#define motorDirPin 4
#define motorPWMPin 5
#define ticksPerDeg 14.26

// Button Variables -------------------------------
const int er0 = 0;
const int prop = 1;
const int inv = 2;
const int vw = 3;
const int er1 = 4;
const int er2 = 5;
int counts = 0;
int key_Pressed = er0;

// Virtual Wall Variables -------------------------------
float angleVal = 0.0;
float prevAngleVal = 0.0;
float velocity = 0.0;
float targetPos = 0.0;
double duty = 0;                  // duty cycle (between 0 and 255)
unsigned int motorCommand = 0;
float PDOutput = 0;
float pGain = .1;
float totalTorque = 0.0;
float posError = 0;
float samplingTime = 0.0;
unsigned long prevTime =  0;
unsigned long currentTime =  0;
float oldVelocity = 0.0;
float tau = 1/300;

// Ringing Variables -------------------------------------
float omega = 5; // rad/s
float kr = 1; 
float kosc = 1;
float d = 2000; // duration, in milliseconds

void setup() {
  pinMode(sensorInput, INPUT);
  pinMode(motorPWMPin, OUTPUT);
  pinMode(motorDirPin, OUTPUT);
  pinMode(13, OUTPUT);  //we'll use the debug LED to output a heartbeat
  Serial.begin(9600);
  while (!Serial);    // Pause until serial link is established. 
                      // Comment out if not using USB connection
  // Set PWM Frequency
  setPwmFrequency(motorPWMPin,1);

  // Read values to initialize "previous" variables
  prevAngleVal = analogRead(sensorInput);
  prevTime = millis();
  
  // Print instructions one time
  Serial.println();
  Serial.println("Press S1 = proportional magnitudes");
  Serial.println("Press S2 = inverse magnitudes");
  Serial.println("Press S3 = virtual wall");
  Serial.println();
  Serial.println("Press and hold buttons to switch between modes");
 
}

void loop()
{
  key_Pressed = Read_Buttons();  // read the buttons

  switch (key_Pressed)           // Do something based on the button pressed
  { 
    case prop:
      {
        analogWrite(motorPWMPin,0);
        counts = 1;
        Serial.println("proportional magnitudes"); // Print the key that was pressed
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case inv:
      {
        analogWrite(motorPWMPin,0);
        counts = 2;
        Serial.println("inverse magnitudes");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case vw:
      {
        analogWrite(motorPWMPin,0);
        counts = 3;
        Serial.println("virtual wall");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case er1:
      {
        Serial.println("press a different button");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case er2:
      {
        Serial.println("press a different button");
        delay(6000);                                // Delay for switch debounce
      }
    case er0:
      {
        break;
      }
  }
  if(key_Pressed != er0)   // Blink LED and debounce switch
  {
  digitalWrite(13, HIGH);  // Turn LED on
  delay(500);              // Delay for switch debounce & LED blink
  digitalWrite(13, LOW);   // Turn LED off
  }

  
  //-----------------------------------------------------------------------------
  // Proportional rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  if(counts == 1){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;
       
       // If the paddle is in the wall, execute the ringing:       
       if(angleVal < 0) {

        // set execute to 1
        execute = 1;
        
        // Determine time that has passed since the last update;
        currentTime = millis(); // In milliseconds
        initTime = currentTime; // In milliseconds
        samplingTime = (currentTime - prevTime)/(1*1000.0); // In seconds
        
        // Filtering ////////////////////////////////////////////////////////////
    
        // Filter position and reassign
        angleVal = (angleVal + (tau/samplingTime)*prevAngleVal)/((tau/samplingTime)+1);
     
        // Compute unfiltered angular velocity
        velocity = (angleVal - prevAngleVal)/samplingTime;
       
        // Filter velocity and reassign
        velocity = (velocity + (tau/samplingTime)*oldVelocity)/((tau/samplingTime)+1);

        /////////////////////////////////////////////////////////////////////////
       
        // execute ringing
        while(currentTime < (initTime + d)){
          // Define recoil force
          Fr = velocity*kr*(d-initTime);

          // Define oscillation force
          Fosc = velocity*kosc*(d-(currentTime-initTime))*sin(omega*(currentTime-initTime));

          // Deliver forces

          // calculate current time
          currentTime = millis();
        }
       
       }
       
       else{
        analogWrite(motorPWMPin,0);
       }
  }
  
  //-----------------------------------------------------------------------------
  // Inverse rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  else if(counts == 2){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;

       // If the paddle is in the wall, execute the ringing
       if(angleVal < 0) {
        // execute the ringing
       }
       
       else{
        analogWrite(motorPWMPin,0);
       }
  }
  
  //-----------------------------------------------------------------------------
  // Virtual Wall
  //-----------------------------------------------------------------------------
  else if(counts == 3){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;
    
       // Determine time that has passed since the last update;
       currentTime = millis(); // In milliseconds
       samplingTime = (currentTime - prevTime)/(1*1000.0); // In seconds
    
       
       // Filtering ////////////////////////////////////////////////////////////
    
       // Filter position and reassign
       angleVal = (angleVal + (tau/samplingTime)*prevAngleVal)/((tau/samplingTime)+1);
    
       // Compute unfiltered angular velocity
       velocity = (angleVal - prevAngleVal)/samplingTime;
       
       // Filter velocity and reassign
       velocity = (velocity + (tau/samplingTime)*oldVelocity)/((tau/samplingTime)+1);
    
      /////////////////////////////////////////////////////////////////////////
    
       posError = targetPos-angleVal;
    
       PDOutput = posError*pGain;
    
       totalTorque = PDOutput;
       
    if(angleVal <= 0) {
       // Determine correct direction for motor torque
      if(totalTorque > 0.0) { 
        digitalWrite(motorDirPin, HIGH);
      } else {
        digitalWrite(motorDirPin, LOW);
      }
    
      // Compute the duty cycle required to generate torque at the motor
      duty = sqrt(abs(totalTorque)/0.03);
    
      // Make sure the duty cycle is between 0 and 100%
      if (duty > 1) {            
        duty = 1;
      } else if (duty < 0) { 
        duty = 0;
      } 
       
      motorCommand = (int)(duty*255);   // convert duty cycle to output signal
      analogWrite(motorPWMPin,motorCommand);  // output the signal
         
       // Update values with the current state
       prevAngleVal = angleVal;
       prevTime = currentTime;
     }
    else{
      // output 0 power to motor
      analogWrite(motorPWMPin,0);
    
      // Update values with current state
      prevAngleVal = angleVal;
      prevTime = currentTime;
    }
    
      // Set old velocity for filter
      oldVelocity = velocity;
  }
}
//-------------------------------------------------------------------------------
//  Read Buttons - Subroutine to read the ADC and return the button value
//-------------------------------------------------------------------------------
int Read_Buttons()
{
  int adc_key_in = analogRead(A7);      // read the value of the key resistor divider
  // The buttons are connected to a voltage divider that feeds into analog input A0.
  // By looking at the voltage level, we can tell which button has been pressed if any.
  // With no button pressed, the voltage will be pulled up to Vcc.
    //Serial.println (adc_key_in);
  if (adc_key_in >= 1000) return er0; // Most likely result, so it is the first option.
  if (adc_key_in < 30)   return prop; // Work our way up the voltage ladder and return 1st valid result
  if (adc_key_in < 200)  return inv;
  if (adc_key_in < 500)  return vw;
  if (adc_key_in < 700)  return er1;
  if (adc_key_in < 990)  return er2;

  return er0;  // when all others fail, return this...
}

// --------------------------------------------------------------
// Function to set PWM Freq -- DO NOT EDIT
// --------------------------------------------------------------
void setPwmFrequency(int pin, int divisor) {
  byte mode;
  if(pin == 5 || pin == 6 || pin == 9 || pin == 10) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 64: mode = 0x03; break;
      case 256: mode = 0x04; break;
      case 1024: mode = 0x05; break;
      default: return;
    }
    if(pin == 5 || pin == 6) {
      TCCR0B = TCCR0B & 0b11111000 | mode;
    } else {
      TCCR1B = TCCR1B & 0b11111000 | mode;
    }
  } else if(pin == 3 || pin == 11) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 32: mode = 0x03; break;
      case 64: mode = 0x04; break;
      case 128: mode = 0x05; break;
      case 256: mode = 0x06; break;
      case 1024: mode = 0x7; break;
      default: return;
    }
    TCCR2B = TCCR2B & 0b11111000 | mode;
  }
}d = 0;
float PDOutput = 0;
float pGain = .1;
float totalTorque = 0.0;
float posError = 0;
float samplingTime = 0.0;
unsigned long prevTime =  0;
unsigned long currentTime =  0;
float oldVelocity = 0.0;
float tau = 1/300;

// Ringing Variables -------------------------------------
float omega = 5; // rad/s
float kr = 1; 
float kosc = 1;

void setup() {
  pinMode(sensorInput, INPUT);
  pinMode(motorPWMPin, OUTPUT);
  pinMode(motorDirPin, OUTPUT);
  pinMode(13, OUTPUT);  //we'll use the debug LED to output a heartbeat
  Serial.begin(9600);
  while (!Serial);    // Pause until serial link is established. 
                      // Comment out if not using USB connection
  // Set PWM Frequency
  setPwmFrequency(motorPWMPin,1);

  // Read values to initialize "previous" variables
  prevAngleVal = analogRead(sensorInput);
  prevTime = millis();
  
  // Print instructions one time
  Serial.println();
  Serial.println("Press S1 = proportional magnitudes");
  Serial.println("Press S2 = inverse magnitudes");
  Serial.println("Press S3 = virtual wall");
  Serial.println();
  Serial.println("Press and hold buttons to switch between modes");
 
}

void loop()
{
  key_Pressed = Read_Buttons();  // read the buttons

  switch (key_Pressed)           // Do something based on the button pressed
  { 
    case prop:
      {
        analogWrite(motorPWMPin,0);
        counts = 1;
        Serial.println("proportional magnitudes"); // Print the key that was pressed
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case inv:
      {
        analogWrite(motorPWMPin,0);
        counts = 2;
        Serial.println("inverse magnitudes");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case vw:
      {
        analogWrite(motorPWMPin,0);
        counts = 3;
        Serial.println("virtual wall");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case er1:
      {
        Serial.println("press a different button");
        delay(6000);                                // Delay for switch debounce
        break;
      }
    case er2:
      {
        Serial.println("press a different button");
        delay(6000);                                // Delay for switch debounce
      }
    case er0:
      {
        break;
      }
  }
  if(key_Pressed != er0)   // Blink LED and debounce switch
  {
  digitalWrite(13, HIGH);  // Turn LED on
  delay(500);              // Delay for switch debounce & LED blink
  digitalWrite(13, LOW);   // Turn LED off
  }

  
  //-----------------------------------------------------------------------------
  // Proportional rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  if(counts == 1){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;

       // If the paddle is in the wall, execute the ringing:       
       if(angleVal < 0) {
        // Determine time that has passed since the last update;
        currentTime = millis(); // In milliseconds
        samplingTime = (currentTime - prevTime)/(1*1000.0); // In seconds
        
        // Filtering ////////////////////////////////////////////////////////////
    
        // Filter position and reassign
        angleVal = (angleVal + (tau/samplingTime)*prevAngleVal)/((tau/samplingTime)+1);
     
        // Compute unfiltered angular velocity
        velocity = (angleVal - prevAngleVal)/samplingTime;
       
        // Filter velocity and reassign
        velocity = (velocity + (tau/samplingTime)*oldVelocity)/((tau/samplingTime)+1);

        /////////////////////////////////////////////////////////////////////////
       
        // Define recoil force
        Fr = velocity*kr*(d-currentTime);

        // Define oscillation force
        Fosc = velocity*kosc*(d-currentTime)*sin(omega*currentTime);
       }
       
       else{
        analogWrite(motorPWMPin,0);
       }
  }
  
  //-----------------------------------------------------------------------------
  // Inverse rel'n between incoming velocity and ringing amplitude
  //-----------------------------------------------------------------------------
  else if(counts == 2){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;

       // If the paddle is in the wall, execute the ringing
       if(angleVal < 0) {
        // execute the ringing
       }
       
       else{
        analogWrite(motorPWMPin,0);
       }
  }
  
  //-----------------------------------------------------------------------------
  // Virtual Wall
  //-----------------------------------------------------------------------------
  else if(counts == 3){
       // Read the current state of sensors
       angleVal = (512.0 - analogRead(sensorInput))/ticksPerDeg;
    
       // Determine time that has passed since the last update;
       currentTime = millis(); // In milliseconds
       samplingTime = (currentTime - prevTime)/(1*1000.0); // In seconds
    
       
       // Filtering ////////////////////////////////////////////////////////////
    
       // Filter position and reassign
       angleVal = (angleVal + (tau/samplingTime)*prevAngleVal)/((tau/samplingTime)+1);
    
       // Compute unfiltered angular velocity
       velocity = (angleVal - prevAngleVal)/samplingTime;
       
       // Filter velocity and reassign
       velocity = (velocity + (tau/samplingTime)*oldVelocity)/((tau/samplingTime)+1);
    
      /////////////////////////////////////////////////////////////////////////
    
       posError = targetPos-angleVal;
    
       PDOutput = posError*pGain;
    
       totalTorque = PDOutput;
       
    if(angleVal <= 0) {
       // Determine correct direction for motor torque
      if(totalTorque > 0.0) { 
        digitalWrite(motorDirPin, HIGH);
      } else {
        digitalWrite(motorDirPin, LOW);
      }
    
      // Compute the duty cycle required to generate torque at the motor
      duty = sqrt(abs(totalTorque)/0.03);
    
      // Make sure the duty cycle is between 0 and 100%
      if (duty > 1) {            
        duty = 1;
      } else if (duty < 0) { 
        duty = 0;
      } 
       
      motorCommand = (int)(duty*255);   // convert duty cycle to output signal
      analogWrite(motorPWMPin,motorCommand);  // output the signal
         
       // Update values with the current state
       prevAngleVal = angleVal;
       prevTime = currentTime;
     }
    else{
      // output 0 power to motor
      analogWrite(motorPWMPin,0);
    
      // Update values with current state
      prevAngleVal = angleVal;
      prevTime = currentTime;
    }
    
      // Set old velocity for filter
      oldVelocity = velocity;
  }
}
//-------------------------------------------------------------------------------
//  Read Buttons - Subroutine to read the ADC and return the button value
//-------------------------------------------------------------------------------
int Read_Buttons()
{
  int adc_key_in = analogRead(A7);      // read the value of the key resistor divider
  // The buttons are connected to a voltage divider that feeds into analog input A0.
  // By looking at the voltage level, we can tell which button has been pressed if any.
  // With no button pressed, the voltage will be pulled up to Vcc.
    //Serial.println (adc_key_in);
  if (adc_key_in >= 1000) return er0; // Most likely result, so it is the first option.
  if (adc_key_in < 30)   return prop; // Work our way up the voltage ladder and return 1st valid result
  if (adc_key_in < 200)  return inv;
  if (adc_key_in < 500)  return vw;
  if (adc_key_in < 700)  return er1;
  if (adc_key_in < 990)  return er2;

  return er0;  // when all others fail, return this...
}

// --------------------------------------------------------------
// Function to set PWM Freq -- DO NOT EDIT
// --------------------------------------------------------------
void setPwmFrequency(int pin, int divisor) {
  byte mode;
  if(pin == 5 || pin == 6 || pin == 9 || pin == 10) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 64: mode = 0x03; break;
      case 256: mode = 0x04; break;
      case 1024: mode = 0x05; break;
      default: return;
    }
    if(pin == 5 || pin == 6) {
      TCCR0B = TCCR0B & 0b11111000 | mode;
    } else {
      TCCR1B = TCCR1B & 0b11111000 | mode;
    }
  } else if(pin == 3 || pin == 11) {
    switch(divisor) {
      case 1: mode = 0x01; break;
      case 8: mode = 0x02; break;
      case 32: mode = 0x03; break;
      case 64: mode = 0x04; break;
      case 128: mode = 0x05; break;
      case 256: mode = 0x06; break;
      case 1024: mode = 0x7; break;
      default: return;
    }
    TCCR2B = TCCR2B & 0b11111000 | mode;
  }
}
